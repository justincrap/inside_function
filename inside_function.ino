#include <WiFiEsp.h>
#include <WiFiEspClient.h>
#include <WiFiEspServer.h>
#include <WiFiEspUdp.h>

int ledArray[] = {36, 37, 38}; // ledArray[0] is green, ledArray[1] is red, ledArray[2] is yellow, and ledArray[3] is blue.
int buttonArray[] = {26, 28, 30}; // buttonArray[0] is green, buttonArray[1] is red, buttonArray[2] is yellow, and buttonArray[3] is blue.
#define NUMBERTOWIN 7 //Number of lights you have to match to win
int pinCount = 3;
int ledState = 0;
int gameState = 0;
int gameValues[NUMBERTOWIN];
int roundNum = 0;

unsigned long previousMillis = 0;
unsigned long interval1 = 500;

void setLed(int ledNum);
void displayClue(int roundNum);
boolean waitForInput(int buttonNum);

//TODO: IR SpO2 sensor, +photo, memorygame,website
const unsigned char epd_bitmap_heartbeat[] PROGMEM = {  // print heartbeat image
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xe0, 0x00, 0x7f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x1f, 0x80, 0x00, 0x3f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0x07, 0x00, 0x00, 0x0f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xc2, 0x0f, 0xf8, 0x07, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xe0, 0x1f, 0xfe, 0x03, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xf0, 0x7f, 0xff, 0x01, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0x81, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xfc, 0xff, 0x7f, 0x80, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x80, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xc0, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xc0, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x9f, 0xc0, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7e, 0xdf, 0x80, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7e, 0xdf, 0x80, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xef, 0x81, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xbd, 0xef, 0x01, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe6, 0x9d, 0xf7, 0x03, 0xff,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xdd, 0xf0, 0x03, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xdd, 0xfe, 0x07, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed, 0xfc, 0x0f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xeb, 0xf8, 0x0f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf0, 0x1f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xe0, 0x3f, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xc0, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0x81, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0x03, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// 'chess_bmp', 128x64px
const unsigned char epd_bitmap_chess_bmp[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xe0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x03, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x0f, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3f, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3f, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0x7f, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x7f, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3f, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x1f, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0x3f, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0x7f, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x8f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x8f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x8f, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x0f, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x0f, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x1f, 0xfe, 0x3f, 0xff, 0xfe, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x3f, 0xfe, 0x1f, 0xff, 0x86, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3f, 0xfe, 0x1f, 0xff, 0x7e, 0xff, 0xff, 0xef, 0xff, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3f, 0xff, 0x1f, 0xfe, 0xfe, 0xff, 0xff, 0xef, 0xff, 0xff, 0xef, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3f, 0xff, 0x0f, 0xfe, 0xfe, 0x9e, 0x3c, 0x6c, 0xa6, 0x78, 0xc3, 0x1f, 0xff,
  0xff, 0xff, 0xfc, 0x7f, 0xff, 0x8f, 0xfe, 0xfe, 0x6d, 0xdb, 0xeb, 0x99, 0xbf, 0x6e, 0xef, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x87, 0xfe, 0xfe, 0xec, 0x1b, 0xe7, 0xbb, 0xb8, 0x6e, 0x0f, 0xff,
  0xff, 0xff, 0xf8, 0xff, 0xff, 0x83, 0xfe, 0xfe, 0xed, 0xfb, 0xe3, 0xbb, 0xb7, 0x6e, 0xff, 0xff,
  0xff, 0xff, 0xf9, 0xff, 0xff, 0xc3, 0xff, 0x7e, 0xed, 0xfb, 0xed, 0xbb, 0xb7, 0x6e, 0xff, 0xff,
  0xff, 0xff, 0xf1, 0xff, 0xff, 0xe3, 0xff, 0x8e, 0xee, 0x3c, 0x6e, 0xbb, 0xb0, 0x73, 0x1f, 0xff,
  0xff, 0xff, 0xf1, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf3, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf3, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf3, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xe7, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xc7, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// 'BLOOD O2', 59x75px
const unsigned char epd_bitmap_BLOOD_O2[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0x80, 0x1f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x40, 0x0f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xfe, 0x00, 0x07, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xf0, 0x08, 0x00, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x7f, 0xff, 0xe0,
  0xff, 0xff, 0xe0, 0x1c, 0x00, 0x7f, 0xff, 0xe0, 0xff, 0xff, 0xe0, 0x7e, 0x00, 0x3f, 0xff, 0xe0,
  0xff, 0xff, 0x80, 0x7f, 0x00, 0x1f, 0xff, 0xe0, 0xff, 0xff, 0xa2, 0x7f, 0x00, 0x1f, 0xff, 0xe0,
  0xff, 0xff, 0x00, 0x7f, 0x00, 0x0f, 0xff, 0xe0, 0xff, 0xfe, 0x01, 0x7e, 0x00, 0x0f, 0xff, 0xe0,
  0xff, 0xfe, 0x00, 0x7e, 0x00, 0x07, 0xff, 0xe0, 0xff, 0xfc, 0x80, 0x00, 0x1f, 0x83, 0xff, 0xe0,
  0xff, 0xfc, 0x00, 0x00, 0x3f, 0xc3, 0xff, 0xe0, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xe1, 0xff, 0xe0,
  0xff, 0xf0, 0x00, 0x00, 0x3f, 0xe1, 0xff, 0xe0, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xe0, 0xff, 0xe0,
  0xff, 0xe0, 0x00, 0x00, 0x3f, 0xe0, 0x7f, 0xe0, 0xff, 0xe8, 0x00, 0x00, 0x3f, 0xe0, 0x7f, 0xe0,
  0xff, 0xe0, 0x00, 0x00, 0x3f, 0xc0, 0x7f, 0xe0, 0xff, 0xc0, 0x00, 0x00, 0x1f, 0x80, 0x3f, 0xe0,
  0xff, 0x80, 0x00, 0x00, 0x02, 0x00, 0x1f, 0xe0, 0xff, 0x80, 0x00, 0x0e, 0x00, 0x00, 0x1f, 0xe0,
  0xff, 0x10, 0x00, 0xff, 0xf0, 0x00, 0x0f, 0xe0, 0xff, 0x00, 0x13, 0xff, 0xfc, 0x00, 0x0f, 0xe0,
  0xff, 0x00, 0x07, 0xff, 0xfe, 0x00, 0x0f, 0xe0, 0xfe, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x07, 0xe0,
  0xfc, 0x00, 0x1f, 0xff, 0xff, 0x80, 0x03, 0xe0, 0xfc, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x03, 0xe0,
  0xfc, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0x03, 0xe0, 0xfc, 0x00, 0x7f, 0xc0, 0x3f, 0xe0, 0x03, 0xe0,
  0xfc, 0x00, 0x7f, 0x80, 0x3f, 0xe0, 0x01, 0xe0, 0xf8, 0x00, 0xff, 0x0f, 0x1f, 0xf0, 0x01, 0xe0,
  0xf8, 0x01, 0xfe, 0x3f, 0x87, 0xf0, 0x01, 0xe0, 0xf8, 0x01, 0xfe, 0x3f, 0xc7, 0xf0, 0x01, 0xe0,
  0xf8, 0x01, 0xfe, 0x3f, 0xc7, 0xf0, 0x01, 0xe0, 0xf8, 0x01, 0xfe, 0x3f, 0xc7, 0xf0, 0x01, 0xe0,
  0xf8, 0x01, 0xfe, 0x3f, 0xc7, 0xf8, 0x01, 0xe0, 0xf8, 0x01, 0xfe, 0x3f, 0xc7, 0xf0, 0x01, 0xe0,
  0xf8, 0x01, 0xfe, 0x3f, 0xc4, 0xf0, 0x01, 0xe0, 0xf8, 0x01, 0xff, 0x1f, 0x8f, 0x70, 0x01, 0xe0,
  0xfc, 0x00, 0xff, 0x86, 0x1f, 0x70, 0x01, 0xe0, 0xfc, 0x00, 0xff, 0x80, 0x3e, 0xf0, 0x03, 0xe0,
  0xfd, 0x00, 0x7f, 0xe0, 0xfc, 0xe0, 0x03, 0xe0, 0xfc, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0x03, 0xe0,
  0xfe, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0x03, 0xe0, 0xff, 0x00, 0x1f, 0xff, 0xff, 0x80, 0x07, 0xe0,
  0xff, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x0f, 0xe0, 0xff, 0x10, 0x0f, 0xff, 0xff, 0x00, 0x0f, 0xe0,
  0xff, 0x80, 0x03, 0xff, 0xfc, 0x00, 0x1f, 0xe0, 0xff, 0xd0, 0x00, 0x7f, 0xe0, 0x00, 0x3f, 0xe0,
  0xff, 0xe0, 0x00, 0x3f, 0xc0, 0x00, 0x3f, 0xe0, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0,
  0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0,
  0xff, 0xfe, 0x00, 0x00, 0x00, 0x07, 0xff, 0xe0, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0,
  0xff, 0xff, 0x80, 0x00, 0x00, 0x1f, 0xff, 0xe0, 0xff, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xc0, 0x3f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0
};

// 'eye54x38', 54x38px
const unsigned char epd_bitmap_eye54x38[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xfc, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xc0, 0x00, 0x3f, 0xff, 0xfc, 0xff,
  0xfe, 0x00, 0x00, 0x07, 0xff, 0xfc, 0xff, 0xfc, 0x00, 0x60, 0x01, 0xff, 0xfc, 0xff, 0xf0, 0x03,
  0xfe, 0x00, 0x7f, 0xfc, 0xff, 0xc0, 0x0f, 0xff, 0x00, 0x3f, 0xfc, 0xff, 0x80, 0x1f, 0x9f, 0x80,
  0x1f, 0xfc, 0xff, 0x00, 0x3c, 0x1f, 0xc0, 0x0f, 0xfc, 0xfe, 0x00, 0x78, 0x1f, 0xe0, 0x03, 0xfc,
  0xfc, 0x00, 0x70, 0x1f, 0xe0, 0x01, 0xfc, 0xf8, 0x00, 0x70, 0x1f, 0x70, 0x00, 0xfc, 0xf0, 0x00,
  0xe0, 0x0e, 0x70, 0x00, 0xfc, 0xe0, 0x00, 0xe0, 0x00, 0x70, 0x00, 0x7c, 0xe0, 0x00, 0xe0, 0x00,
  0x70, 0x00, 0x7c, 0xf0, 0x00, 0xe0, 0x00, 0x70, 0x00, 0x7c, 0xf8, 0x00, 0xf0, 0x00, 0x70, 0x00,
  0xfc, 0xf8, 0x00, 0x70, 0x00, 0xf0, 0x01, 0xfc, 0xfc, 0x00, 0x78, 0x00, 0xe0, 0x03, 0xfc, 0xfe,
  0x00, 0x3c, 0x01, 0xe0, 0x07, 0xfc, 0xff, 0x80, 0x1f, 0x07, 0xc0, 0x0f, 0xfc, 0xff, 0xc0, 0x0f,
  0xff, 0x80, 0x3f, 0xfc, 0xff, 0xe0, 0x07, 0xfe, 0x00, 0x7f, 0xfc, 0xff, 0xf8, 0x01, 0xf8, 0x01,
  0xff, 0xfc, 0xff, 0xfe, 0x00, 0x00, 0x03, 0xff, 0xfc, 0xff, 0xff, 0x80, 0x00, 0x1f, 0xff, 0xfc,
  0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc
};

// 'pulse', 59x49px
const unsigned char epd_bitmap_pulse[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xaf, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x2f, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0x67, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x67, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xbf, 0xfe, 0x67, 0xff, 0xfb, 0xff, 0xe0, 0xff, 0xbf, 0xfe, 0x67, 0xff, 0xfb, 0xff, 0xe0,
  0xff, 0x1f, 0xfe, 0x67, 0xff, 0xf1, 0xff, 0xe0, 0xff, 0x5f, 0xfe, 0xe7, 0xff, 0xf1, 0xff, 0xe0,
  0xff, 0x5f, 0xfc, 0xe7, 0xff, 0xf5, 0xff, 0xe0, 0xff, 0x5f, 0xfd, 0xf7, 0xff, 0xe5, 0xff, 0xe0,
  0xfe, 0xd8, 0x01, 0xf7, 0xe0, 0x05, 0xff, 0xe0, 0xff, 0xd8, 0x01, 0xf3, 0xc0, 0x0d, 0xbf, 0xe0,
  0xff, 0xeb, 0xff, 0xf3, 0xdf, 0xfe, 0xbf, 0xe0, 0xff, 0xeb, 0xff, 0xf3, 0xdf, 0xfe, 0xff, 0xe0,
  0xff, 0xe3, 0xff, 0xfb, 0x9f, 0xfe, 0xff, 0xe0, 0xff, 0xe7, 0xff, 0xfb, 0x9f, 0xfe, 0x7f, 0xe0,
  0xff, 0xe7, 0xff, 0xf9, 0x9f, 0xfe, 0x7f, 0xe0, 0xff, 0xe7, 0xff, 0xf9, 0xbf, 0xff, 0x7f, 0xe0,
  0xff, 0xff, 0xff, 0xf9, 0x3f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xf9, 0x7f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xf9, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0
};

// 'bloodglucose', 59x64px
const unsigned char epd_bitmap_bloodglucose[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xf1, 0x1f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xe3, 0x1f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xc7, 0x8f, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xcf, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x8f, 0xe7, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0x1f, 0xe3, 0xff, 0xff, 0xe0, 0xff, 0xfe, 0xfe, 0x3f, 0xf1, 0xff, 0xff, 0xe0,
  0xff, 0xf8, 0x3f, 0x3f, 0xf9, 0xff, 0xff, 0xe0, 0xff, 0xe0, 0x1f, 0xff, 0xf8, 0xff, 0xff, 0xe0,
  0xff, 0xc3, 0x87, 0xff, 0xfc, 0x7f, 0xff, 0xe0, 0xff, 0x0f, 0xe1, 0xff, 0xfc, 0x7f, 0xff, 0xe0,
  0xfc, 0x3f, 0xf0, 0x7f, 0xfe, 0x3f, 0xff, 0xe0, 0xf8, 0x7f, 0xfc, 0x3f, 0xff, 0x3f, 0xff, 0xe0,
  0xf0, 0xff, 0xfe, 0x3f, 0xff, 0x1f, 0xff, 0xe0, 0xf0, 0x3f, 0xf8, 0x3f, 0xff, 0x9f, 0xff, 0xe0,
  0xf1, 0x0f, 0xe1, 0x3f, 0xff, 0x8f, 0xff, 0xe0, 0xf1, 0x87, 0x87, 0x3f, 0xff, 0xcf, 0xff, 0xe0,
  0xf1, 0xe1, 0x0f, 0x3f, 0xff, 0xc7, 0xff, 0xe0, 0xf1, 0xf8, 0x3f, 0x3f, 0xff, 0xe7, 0xff, 0xe0,
  0xf1, 0xfc, 0xff, 0x3f, 0xff, 0xe3, 0xff, 0xe0, 0xf1, 0xfc, 0xff, 0x3f, 0xff, 0xe3, 0xff, 0xe0,
  0xf1, 0xfc, 0xff, 0x3f, 0xff, 0xf3, 0xff, 0xe0, 0xf1, 0xfc, 0xff, 0x3f, 0xff, 0xf1, 0xff, 0xe0,
  0xf1, 0xfc, 0xff, 0x3f, 0xff, 0xf1, 0xff, 0xe0, 0xf0, 0xfc, 0xfe, 0x3f, 0xff, 0xf9, 0xff, 0xe0,
  0xfc, 0x3c, 0xf8, 0x7f, 0xff, 0xf8, 0xff, 0xe0, 0xfe, 0x0c, 0xe1, 0xff, 0xfe, 0x78, 0xff, 0xe0,
  0xff, 0x84, 0xc3, 0xff, 0xfe, 0x7c, 0xff, 0xe0, 0xff, 0xe0, 0x0f, 0xff, 0xfe, 0x7c, 0xff, 0xe0,
  0xff, 0xf8, 0x3f, 0xff, 0xfe, 0x3c, 0xff, 0xe0, 0xff, 0xfc, 0x7f, 0xff, 0xfe, 0x3c, 0x7f, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x3c, 0x7f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3c, 0x7f, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x3c, 0x7f, 0xe0, 0xff, 0xf8, 0xff, 0xff, 0xfe, 0x3c, 0x7f, 0xe0,
  0xff, 0xfc, 0xff, 0xff, 0xfe, 0x3c, 0x7f, 0xe0, 0xff, 0xfc, 0xff, 0xff, 0xfe, 0x3c, 0x7f, 0xe0,
  0xff, 0xfc, 0xff, 0xff, 0xfe, 0x3c, 0xff, 0xe0, 0xff, 0xfc, 0x7f, 0xff, 0xfc, 0x7c, 0xff, 0xe0,
  0xff, 0xfc, 0x7f, 0xff, 0xf8, 0x78, 0xff, 0xe0, 0xff, 0xfe, 0x3f, 0xff, 0xf0, 0xf8, 0xff, 0xe0,
  0xff, 0xfe, 0x3f, 0xdf, 0xc0, 0xf1, 0xff, 0xe0, 0xff, 0xff, 0x1f, 0xc0, 0x03, 0xf1, 0xff, 0xe0,
  0xff, 0xff, 0x1f, 0xe0, 0x07, 0xe3, 0xff, 0xe0, 0xff, 0xff, 0x8f, 0xf8, 0x3f, 0xc7, 0xff, 0xe0,
  0xff, 0xff, 0xc7, 0xff, 0xff, 0x87, 0xff, 0xe0, 0xff, 0xff, 0xe1, 0xff, 0xff, 0x0f, 0xff, 0xe0,
  0xff, 0xff, 0xf0, 0xff, 0xfc, 0x1f, 0xff, 0xe0, 0xff, 0xff, 0xf8, 0x1f, 0xf0, 0x7f, 0xff, 0xe0,
  0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0
};

#define USE_ARDUINO_INTERRUPTS true
#include <PulseSensorPlayground.h>

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include <MAX3010x.h>  //SPO2
#include "filters.h"

#include <SoftwareSerial.h>
#include <WiFiEsp.h>     //setup wifi
#include <ThingSpeak.h>  //setup thingspeak

#include <Wire.h>
#include <Adafruit_MLX90614.h>  //gas sensor

#define SCREEN_WIDTH 128  // define oled size
#define SCREEN_HEIGHT 64
#define OLED_RESET -1

#define voltageCheckPin A4

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);  // setup oled
Adafruit_MLX90614 mlx = Adafruit_MLX90614();

void spo2sensor();
void pulsesensor();
void blood_glucose();
void buttonWait();
void eyetest();
void memorytest();
void printWifiData();

int status = WL_IDLE_STATUS;
WiFiEspClient client;
char ssid[] = "EE3070_P1615_1"; // your network SSID (name)
char pass[] = "EE3070P1615";    // your network password

//char ssid[] = "candy"; // your network SSID (name)
//char pass[] = "oscar200541";    // your network password

float distance;  // for ultrasonic sensor
int duration;

const int PulseWire = A0;  // pulse sensor pin
const int LED13 = 13;
int Threshold = 550;

int button1 = 52;  // setup button
int button2 = 53;
int cnt = 0;

int eyepoint = 0;

float BGLcounter = 0;
float totalBGL = 0;

int blue_light_pin = 38;  // setup led for body testing
int green_light_pin = 40;
int red_light_pin = 42;

int randomNum = 10;

float analogValue;
float input_voltage;

long total_time[4];  // store reaction time
long time1, time2;

unsigned long PrivateChannelNumber = 1886454;
const char *myWriteAPIKeyPrivate = "8SD0HS3OJ3CDO03O";
const char *myReadAPIKeyPrivate = "FZROAQV5R96WUQUI";

// Sensor (adjust to your sensor type)
MAX30105 sensor;
const auto kSamplingRate = sensor.SAMPLING_RATE_400SPS;
const float kSamplingFrequency = 400.0;

// Finger Detection Threshold and Cooldown
const unsigned long kFingerThreshold = 10000;
const unsigned int kFingerCooldownMs = 500;

// Edge Detection Threshold (decrease for MAX30100)
const float kEdgeThreshold = -2000.0;

// Filters
const float kLowPassCutoff = 5.0;
const float kHighPassCutoff = 0.5;

// Averaging
const bool kEnableAveraging = false;
const int kAveragingSamples = 5;
const int kSampleThreshold = 5;

PulseSensorPlayground pulseSensor;

void setLed(int ledNum);
void displayClue(int roundNum);
boolean waitForInput(int buttonNum);

void setup() {

  sensor.begin();

  pinMode(blue_light_pin, OUTPUT);  // for reaction test
  pinMode(green_light_pin, OUTPUT);
  pinMode(red_light_pin, OUTPUT);

  Serial.begin(115200);
  Serial1.begin(115200);
  WiFi.init(&Serial1);

  pinMode(button1, INPUT);
  pinMode(button2, INPUT);

  pulseSensor.analogInput(PulseWire);
  pulseSensor.blinkOnPulse(LED13);
  pulseSensor.setThreshold(Threshold);

  if (!pulseSensor.begin()) {                    // pulsesensor test availbility
    Serial.println("pulsesensor not working.");  // This prints one time at Arduino power - up,  or on Arduino reset.
  }

  if (WiFi.status() != WL_CONNECTED)  {
    Serial.print("Attempting to connect to SSID ");
    Serial.println(ssid);
    while (WiFi.status() != WL_CONNECTED)    {
      WiFi.begin(ssid, pass); // Connect to WPAWPA2 network

      delay(5000);
    }
    Serial.println("Sucessfully Connected, now initializing...");
  }
  printWifiData();
  ThingSpeak.begin(client);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;
  }

  if (sensor.begin() && sensor.setSamplingRate(kSamplingRate)) {
    Serial.println("SPO2 Sensor initialized");
  } else {
    Serial.println("SPO2 Sensor not found");
    while (1);
  }

  for (int Pin = 0; Pin < pinCount; Pin++){
    pinMode(ledArray[Pin], OUTPUT);
  }

  for (int Pin = 0; Pin < pinCount; Pin++)  {
    pinMode(buttonArray[Pin], INPUT_PULLUP);
  }
  randomSeed(analogRead(0));

  Serial.println("  ");
  Serial.println("  ");
  Serial.println("  ");
  Serial.println("  ");

  Serial.println("Welcome to Checkmate!");
  Serial.println("Press Upper Button to Start.");
  Serial.println("================================================");
  Serial.println("Menu:");
  Serial.println("Mode 1: Icon");
  Serial.println("Mode 2: Pulse measurement");
  Serial.println("Mode 3: SpO2 measurement");
  Serial.println("Mode 4: Blood Glucose Measurement");
  Serial.println("Mode 5: Reaction Test");
  Serial.println("Mode 6: Eye Test");
  Serial.println("Mode 7: Memory Game");
  Serial.println("Mode 8: Battery Level");
}

// Filter Instances
LowPassFilter low_pass_filter_red(kLowPassCutoff, kSamplingFrequency);
LowPassFilter low_pass_filter_ir(kLowPassCutoff, kSamplingFrequency);
HighPassFilter high_pass_filter(kHighPassCutoff, kSamplingFrequency);
Differentiator differentiator(kSamplingFrequency);
MovingAverageFilter<kAveragingSamples> averager_bpm;
MovingAverageFilter<kAveragingSamples> averager_r;
MovingAverageFilter<kAveragingSamples> averager_spo2;

// Statistic for pulse oximetry
MinMaxAvgStatistic stat_red;
MinMaxAvgStatistic stat_ir;

float kSpO2_A = 1.5958422;
float kSpO2_B = -34.6596622;
float kSpO2_C = 112.6898759;

// Timestamp of the last heartbeat
long last_heartbeat = 0;

// Timestamp for finger detection
long finger_timestamp = 0;
bool finger_detected = false;

// Last diff to detect zero crossing
float last_diff = NAN;
bool crossed = false;
long crossed_time = 0;

void loop() {
  display.clearDisplay();
  boolean button1state = LOW;
  boolean button2state = LOW;
  button1state = digitalRead(button1);
  button2state = digitalRead(button2);

  if (button1state == HIGH) {
    //Serial.print(F("button 1 on for "));
    //Serial.println(cnt);
    digitalWrite(button1, LOW);
    displaymenu(cnt);
    cnt = cnt + 1;
    delay(500);
  }
  delay(100);
}

long test_reaction() {
  // put your main code here, to run repeatedly:
  buttonWait(button1, button2);
  for (int i = 0; i < 3; i++) {

    analogWrite(red_light_pin, 255);  // red
    randomNum = random(3, 10);
    while (randomNum > 0) {
      randomNum--;
      delay(1000);
    }
    time1 = micros();
    analogWrite(red_light_pin, 0);     // red
    analogWrite(blue_light_pin, 255);  // blue
    while (digitalRead(button1) == LOW) {
      // time2 = micros();
    }
    time2 = micros();
    total_time[i] = time1 - time2;
    analogWrite(blue_light_pin, 0);  // blue
    randomNum = random(10);
    Serial.println(F("press button 2 for next round"));
    while (digitalRead(button2) == LOW) {
      // empty wait for response
    }
  }

  total_time[4] = 0;
  for (int i = 0; i < 3; i++) {
    total_time[4] = total_time[4] + total_time[i];
  }
  // total_time[4]=total_time[4]/3;
  float finals = abs(total_time[4] / 3000);  // average time unit in ms
  Serial.print(finals);
  Serial.println("ms.");
  display.clearDisplay();
  display.setCursor(0, 0);
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.println("Reaction  Time: ");
  display.print(finals);
  display.display();
  ThingSpeak.setField(5, finals);
  ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);
  delay(1000);
  display.clearDisplay();
  display.setCursor(0, 0);

  // return total_time[4]; //return the average reaction time
}

void pulsesensor() {
  delay(3000);
  int BPMmeasured = 0;
  int totalBPM = 0;
  while (BPMmeasured < 10) {
    int myBPM = pulseSensor.getBeatsPerMinute();

    pulseSensor.sawStartOfBeat();
    if (myBPM > 30 && myBPM < 220) {
      Serial.print("BPM = ");
      Serial.println(myBPM);
      totalBPM += myBPM;
      BPMmeasured += 1;
      delay(500);
    }
  }

  Serial.print("Average BPM = ");
  Serial.println(totalBPM / 10);
  display.clearDisplay();
  display.setCursor(0, 0);
  display.setTextSize(2);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.println("BPM = ");
  display.print(totalBPM / 10);
  display.display();
  ThingSpeak.setField(2, totalBPM / 10);
  ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);
  BPMmeasured = 0;
  totalBPM = 0;
  return;
}

void displaymenu(int a) {
  display.clearDisplay();
  int menuNum = a % 8;

  switch (menuNum) {
    case 0:
      delay(1000);
      display.clearDisplay();
      display.setCursor(0, 0);
      display.drawBitmap(0, 0, epd_bitmap_chess_bmp, 128, 64, WHITE);
      display.display();
      break;

    case 1:
      Serial.println(F("Mode 2: Pulse Measurement"));
      Serial.println(F("Please place your thunb on the pulse sensor and wait a few second."));

      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 2: "));
      display.println(F("Pulse "));
      display.println(F("Measure"));
      display.display();
      delay(1000);
      display.clearDisplay();
      while (digitalRead(button1) == LOW) {
        pulsesensor();
      }
      break;

    case 2:
      Serial.println(F("Mode 3: SpO2 Measurement"));
      Serial.println(F("Please place your thunb on the SpO2 sensor and wait a few second."));

      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 3: "));
      display.println(F("SpO2 "));
      display.println(F("Measure"));
      display.display();
      spo2sensor();
      break;

    case 3:
      Serial.print(F("Mode 4: Blood Glucose Measurement"));
      Serial.println(F("Please blow air into gas sensor from above."));
      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 4: "));
      display.println(F("Blood "));
      display.println(F("Glucose "));
      display.println(F("Measure"));
      display.display();
      delay(1000);
      blood_glucose();
      break;
      
    case 4:
      display.clearDisplay();
      Serial.println(F("Mode 5: Reaction Game"));
      Serial.println(F("Press button 1 when the LED turns BLUE"));
      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 5: "));
      display.println(F("Reaction "));
      display.println(F("Game "));
      display.display();
      delay(1000);

      test_reaction();
      break;

    case 5:
      display.clearDisplay();
      Serial.println(F("Mode 6: Eye Test"));
      Serial.println(F("Please place the device about 30cm far from your eye level"));
      Serial.println(F("Press button 1 if you can see the word."));
      Serial.println(F("Press button 2 if you cannot see the word."));
      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 6: "));
      display.println(F("Eye Test "));
      display.display();
      eyetest();
      break;

    case 6:
      display.clearDisplay();
      Serial.println(F("Mode 7: Memory Test"));
      Serial.println(F("Three button represent three different color."));
      Serial.println(F("Please the button accroding to LED's color."));
      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 7: "));
      display.println(F("Memory    Test"));
      display.display();
      memorytest();
      break;

    case 7:
      display.clearDisplay();
      Serial.println(F("Mode 8:"));
      Serial.print(F("Battery "));
      Serial.print(F("Level"));
      display.setCursor(0, 0);
      display.setTextSize(2);
      display.setTextColor(SSD1306_WHITE);
      display.println(F("Mode 8: "));
      display.println(F("Battery"));
      display.println(F("level"));
      display.display();
      BatteryLevelCheck();
      break;
  }
  return;
}

void printWifiData() {
  // print your WiFi shield's IP address
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address ");
  Serial.print(ip);
  Serial.print(".");
  if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0) {
    Serial.println(" IP FALL !!!");
  }
  Serial.println();
}

void spo2sensor() {
  float spo2now;
  while (digitalRead(53) == LOW) {
    auto sample = sensor.readSample(1000);
    float current_value_red = sample.red;
    float current_value_ir = sample.ir;

    // Detect Finger using raw sensor value
    if (sample.red > kFingerThreshold) {
      if (millis() - finger_timestamp > kFingerCooldownMs) {
        finger_detected = true;
      }
    } else {
      // Reset values if the finger is removed
      differentiator.reset();
      averager_bpm.reset();
      averager_r.reset();
      averager_spo2.reset();
      low_pass_filter_red.reset();
      low_pass_filter_ir.reset();
      high_pass_filter.reset();
      stat_red.reset();
      stat_ir.reset();

      finger_detected = false;
      finger_timestamp = millis();
    }

    if (finger_detected) {
      current_value_red = low_pass_filter_red.process(current_value_red);
      current_value_ir = low_pass_filter_ir.process(current_value_ir);

      // Statistics for pulse oximetry
      stat_red.process(current_value_red);
      stat_ir.process(current_value_ir);

      // Heart beat detection using value for red LED
      float current_value = high_pass_filter.process(current_value_red);
      float current_diff = differentiator.process(current_value);

      // Valid values?
      if (!isnan(current_diff) && !isnan(last_diff)) {

        // Detect Heartbeat - Zero-Crossing
        if (last_diff > 0 && current_diff < 0) {
          crossed = true;
          crossed_time = millis();
        }

        if (current_diff > 0) {
          crossed = false;
        }

        // Detect Heartbeat - Falling Edge Threshold
        if (crossed && current_diff < kEdgeThreshold) {
          if (last_heartbeat != 0 && crossed_time - last_heartbeat > 300) {
            // Show Results
            int bpm = 60000 / (crossed_time - last_heartbeat);
            float rred = (stat_red.maximum() - stat_red.minimum()) / stat_red.average();
            float rir = (stat_ir.maximum() - stat_ir.minimum()) / stat_ir.average();
            float r = rred / rir;
            float spo2 = kSpO2_A * r * r + kSpO2_B * r + kSpO2_C;

            if (bpm > 50 && bpm < 250) {
              // Average?
              if (kEnableAveraging) {
                int average_bpm = averager_bpm.process(bpm);
                int average_r = averager_r.process(r);
                int average_spo2 = averager_spo2.process(spo2);

                // Show if enough samples have been collected
                if (averager_bpm.count() >= kSampleThreshold) {
                  Serial.print("Time (ms): ");
                  Serial.println(millis());
                  Serial.print("Heart Rate (avg, bpm): ");
                  Serial.println(average_bpm);
                  Serial.print("R-Value (avg): ");
                  Serial.println(average_r);
                  Serial.print("SpO2 (avg, %): ");
                  Serial.println(average_spo2);
                }
              } else {
                Serial.print("Time (ms): ");
                Serial.println(millis());
                Serial.print("Heart Rate (current, bpm): ");
                Serial.println(bpm);
                Serial.print("R-Value (current): ");
                Serial.println(r);
                Serial.print("SpO2 (current, %): ");
                Serial.println(spo2);
                spo2now = spo2;
              }
            }

            // Reset statistic
            stat_red.reset();
            stat_ir.reset();
          }

          crossed = false;
          last_heartbeat = crossed_time;
        }
      }

      last_diff = current_diff;
    }

  }
  if (spo2now > 0) {
    display.clearDisplay();
    display.setTextSize(2);
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE);
    display.println(F("Spo2% : "));
    display.println(spo2now);
    display.display();
    ThingSpeak.setField(3, spo2now);
    ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);
  }


}

void blood_glucose() {
  float sendBGL;
  while (digitalRead(button2) == LOW) {
    while (BGLcounter < 10) {
      float gas_sensor_value = analogRead(A7);
      float Volt = gas_sensor_value * 5 / 1024.0;
      float BGL = (158.12 * Volt) - 269.35;
      Serial.println(BGL);
      totalBGL += BGL;
      delay(100);
      BGLcounter++;
    }
    sendBGL = totalBGL / BGLcounter;
    Serial.print("BGL: ");
    Serial.print(sendBGL);
    Serial.println("mg/dl");
    display.clearDisplay();
    display.setTextSize(2);
    display.setCursor(0, 0);
    display.setTextColor(SSD1306_WHITE);
    display.println(F("glucose(mg/dl)"));
    display.println(sendBGL);
    display.display();

    if (BGLcounter == 10) {
      totalBGL = 0;
      BGLcounter = 0;
    }
  }
  if (sendBGL >= 40) {
    ThingSpeak.setField(4, sendBGL);
    ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);
  }

  return;
}

void buttonWait(int buttonPin1, int buttonPin2) {
  int buttonState1 = 0;
  int buttonState2 = 0;
  while (1) {
    buttonState1 = digitalRead(buttonPin1);
    buttonState2 = digitalRead(buttonPin2);
    if (buttonState1 == HIGH) {
      eyepoint = eyepoint + 1;
      return;
    } else if (buttonState2 == HIGH) {
      return;
    }
  }
}
void eyetest() {

  eyepoint = 0;
  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("Welcome to the eye test.");
  display.print("The test is initalizing, please wait...");
  delay(3000);

  // tut for Y/N button, standing length

  display.clearDisplay();  //#1
  display.setTextSize(7);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("F");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);
  display.clearDisplay();
  display.setTextSize(6);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("F P");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);

  display.clearDisplay();
  display.setTextSize(5);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("T O ");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);

  display.clearDisplay();  //#4
  display.setTextSize(4);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("L P E D");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);

  display.clearDisplay();
  display.setTextSize(3);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("P E C F D");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);

  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("E D F C Z P");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);

  display.clearDisplay();  //#7
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print("F E L O P Z D");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2

  delay(1000);

  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.print(F("Your level of eyes  is "));
  display.print(eyepoint);
  display.println("/ 7.");
  display.display();
  Serial.print(F("Your level of eyes  is "));
  Serial.print(eyepoint);
  Serial.print("/ 7.");

  ThingSpeak.setField(6, eyepoint);
  ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);

  buttonWait(button1, button2);  // wait for button press on pin 2
  display.clearDisplay();
  display.setCursor(0, 0);
  display.print("This is   the end of eye test.");
  display.display();
  buttonWait(button1, button2);  // wait for button press on pin 2
}


void BatteryLevelCheck() {  // need 2k ohm resistor
  analogValue = analogRead(voltageCheckPin);
  Serial.println(analogValue);
  delay(1000);
  input_voltage = (analogValue * 5.0) / 1024.0;
  Serial.println(input_voltage);
  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(0, 0);
  display.setTextColor(SSD1306_WHITE);
  display.println(F("Battery   Level"));
  display.println(input_voltage);
  display.display();

  if (input_voltage < 0.50 && input_voltage >= 0.00) {
    Serial.println("10%");
    analogWrite(red_light_pin, 255);  // red
    analogWrite(green_light_pin, 0);  // green
  } else if (input_voltage < 1.00 && input_voltage >= 0.50) {
    Serial.println("20%%");
    analogWrite(red_light_pin, 255);   // red
    analogWrite(green_light_pin, 63);  // green
  } else if (input_voltage < 1.50 && input_voltage >= 1.00) {
    Serial.println("30%");
    analogWrite(red_light_pin, 255);    // red
    analogWrite(green_light_pin, 127);  // green
  } else if (input_voltage < 2.00 && input_voltage >= 1.50) {
    Serial.println("40%");
    analogWrite(red_light_pin, 255);    // red
    analogWrite(green_light_pin, 191);  // green
  } else if (input_voltage < 2.50 && input_voltage >= 2.00) {
    Serial.println("50%");
    analogWrite(red_light_pin, 255);    // red
    analogWrite(green_light_pin, 255);  // green
  } else if (input_voltage < 3.00 && input_voltage >= 2.50) {
    Serial.println("60%");
    analogWrite(red_light_pin, 204);    // red
    analogWrite(green_light_pin, 255);  // green
  } else if (input_voltage < 3.50 && input_voltage >= 3.00) {
    Serial.println("70%");
    analogWrite(red_light_pin, 153);    // red
    analogWrite(green_light_pin, 255);  // green
  } else if (input_voltage < 4.00 && input_voltage >= 3.50) {
    Serial.println("80%");
    analogWrite(red_light_pin, 102);    // red
    analogWrite(green_light_pin, 255);  // green
  } else if (input_voltage < 4.50 && input_voltage >= 4.00) {
    Serial.println("90%");
    analogWrite(red_light_pin, 51);     // red
    analogWrite(green_light_pin, 255);  // green
  } else if (input_voltage < 5.00 && input_voltage >= 4.50) {
    Serial.println("100%");
    analogWrite(red_light_pin, 0);      // red
    analogWrite(green_light_pin, 255);  // green
  }
  delay(500);
}

void memorytest() {
  while (digitalRead(button2) == LOW) {
    if (gameState == 0)
    {
      int button0 = digitalRead(buttonArray[0]);
      int button1 = digitalRead(buttonArray[1]);
      int button2 = digitalRead(buttonArray[2]);
      int button3 = digitalRead(buttonArray[3]);

      //if no buttons are pressed (since button input is pullup we show all buttons pressed) then play pre_game
      if (button0 && button1 && button2 && button3)
      {
        pre_game();
      }
      // if a button is pressed set up for the game
      else
      {
        Serial.println("button Pressed");
        //turn leds off before starting game --> function setLed() states that if ledNum is <0 led is LOW
        setLed(-1);
        //set the round number to zero so you start on the first round
        roundNum = 0;
        delay (1000);
        //set gameState to 1
        gameState = 1;
      }
    }

    if (gameState == 1)
    {
      gamePlay();
    }

    if (gameState == 2)
    {
      //You win!! - play winning sound and scroll through leds (winDisplay)3 times followed by lose display once for good transition.
      //delay to give player time to release button press before winning sound plays
      delay(500);
      winDisplay();
      winDisplay();
      winDisplay();
      loseDisplay();

      Serial.println("winDisplay");
      //delay briefly before running pre_game
      delay (1000);
      //reset gameState to zero to call pre_game
      gameState = 0;
    }

    if (gameState == 3)
    {
      //You lose :( - play losing sound and flash leds (loseDisplay)3 times for good transition.
      //delay to give player time to release button press before losing sound plays
      delay(500);
      loseDisplay();
      loseDisplay();
      loseDisplay();
      Serial.println("loseDisplay");
      //delay briefly before running pre_game
      delay (1000);
      //reset gameState to zero to call pre_game
      gameState = 0;
    }
  }
}

void pre_game()
{
  //Check if enough time has elapsed between leds lighting up
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis > interval1)
  {
    //if enough time has elapsed update lights
    if (ledState == 0)
    {
      Serial.println("pre green");
      setLed(0);
      ledState = 1;
    }
    else if (ledState == 1)
    {
      Serial.println("pre red");
      setLed(1);
      ledState = 2;
    }
    else if (ledState == 2)
    {
      Serial.println("pre yellow");
      setLed(2);
      ledState = 3;
    }
    else if (ledState == 3)
    {
      Serial.println("pre blue");
      setLed(3);
      ledState = 0;
    }
    //reset time
    previousMillis = currentMillis;
  }
}

void gamePlay()
{
  Serial.println("gamePlay");
  //pre-load array with random numbers for game
  for ( int i = 0; i < NUMBERTOWIN; i++)
  {
    //use floor to round number down to nearest integer and random to choose random numbers from 0 to 3 to put in the gameValues array.
    gameValues[i] = floor(random(0, 3));
    Serial.println(gameValues[i], DEC);
  }


  Serial.print("Starting Round ");
  Serial.println(roundNum, DEC);
  for (int r = 0; r < NUMBERTOWIN; r++)
  {
    displayClue(roundNum);

    for (int i = 0; i <= roundNum; i++)
    {
      Serial.print("Wainting for input ");
      Serial.print(i + 1, DEC);
      Serial.print(" of ");
      Serial.print(roundNum + 1, DEC);
      Serial.println("");

      //wait for user input and see if they're correct, if correct wait for next input etc.. if not correct, fail
      if (waitForInput(gameValues[i]))
      {
        //correct input
        if (i == roundNum)
        {
          Serial.println("Correct");
          //check if final round
          if (roundNum == NUMBERTOWIN - 1)
          {
            Serial.println("You Win!");
            // you won!
            // set gameState to 2 to run winning fuction
            display.clearDisplay();
            display.setTextSize(2);
            display.setCursor(0, 0);
            display.setTextColor(SSD1306_WHITE);
            display.println(F("Memory    Level."));
            display.println(roundNum + 1);
            display.print(F(" /7 "));
            display.display();
            ThingSpeak.setField(7, roundNum + 1);
            ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);
            gameState = 2;

            return;
          }
          else
          {
            Serial.println("Continue");
          }
        }
      }
      else
      {
        //incorrect input
        Serial.println("You Lose!");
        display.clearDisplay();
        display.setTextSize(2);
        display.setCursor(0, 0);
        display.setTextColor(SSD1306_WHITE);
        display.println(F("Memory    Level."));
        display.println(roundNum + 1);
        display.print(F(" /7 "));
        display.display();
        ThingSpeak.setField(7, roundNum);
        ThingSpeak.writeFields(PrivateChannelNumber, myWriteAPIKeyPrivate);
        // you lost :(
        // set gameState to 3 to run losing function
        gameState = 3;
        return;
      }
    }
    //User made it through the round, increment round number to continue
    roundNum++;
    //Delay briefly so user has time to see start of next clue
    delay(1000);
  }
}

void setLed(int ledNum)
{
  //if the led number is less than zero turn all the leds off
  if (ledNum < 0)
  {
    for (int i = 0; i < pinCount; i++)
    {
      digitalWrite(ledArray[i], LOW);
    }
  }
  else
  {
    //turn on the specified led, turn off the other leds
    //turn one and only one led on - if i is the same as the number passed in from pre-game then turn on that light, if it is not the same turn off that light
    for (int i = 0; i < pinCount; i++)
    {
      if (i == ledNum)
      {
        digitalWrite(ledArray[i], HIGH);
      }
      else
      {
        digitalWrite(ledArray[i], LOW);
      }
    }
  }
}

void displayClue(int roundNum)
{
  //turn all lights off
  setLed(-1);
  for (int i = 0; i <= roundNum; i++)
  {
    //turn on led that matches current round
    setLed(gameValues[i]);
    delay(750);
    setLed(-1);
    delay(250);
  }
}
boolean waitForInput(int buttonNum)
{
  //read all the buttons continuously until a button is pressed, if a button is pressed check if it's correct and if so return true. if not, return false.
  while (true)
  {
    int button0 = digitalRead(buttonArray[0]);
    int button1 = digitalRead(buttonArray[1]);
    int button2 = digitalRead(buttonArray[2]);
    int button3 = digitalRead(buttonArray[3]);

    //because we are using input_pullup ! indicted a button is pressed --> if any button is pressed go to the rest of the code
    if (!button0 || !button1 || !button2 || !button3)
    {
      //Delay briefly to avoid double counting button press
      delay(250);

      //light up the corresponding led when a button is pressed
      if (buttonNum == 0)
      {
        digitalWrite(ledArray[0], HIGH);
        delay(250);
        digitalWrite(ledArray[0], LOW);
      }
      else if (buttonNum == 1)
      {
        digitalWrite(ledArray[1], HIGH);
        delay(250);
        digitalWrite(ledArray[1], LOW);
      }
      else if (buttonNum == 2)
      {
        digitalWrite(ledArray[2], HIGH);
        delay(250);
        digitalWrite(ledArray[2], LOW);
      }
      else if (buttonNum == 3)
      {
        digitalWrite(ledArray[3], HIGH);
        delay(250);
        digitalWrite(ledArray[3], LOW);
      }

      //check if correct button was pressed
      if (buttonNum == 0 && button0 == 0)
      {
        Serial.println("0 Pressed");
        return true;
      }
      else if (buttonNum == 1 && button1 == 0)
      {
        Serial.println("1 Pressed");
        return true;
      }
      else if (buttonNum == 2 && button2 == 0)
      {
        Serial.println("2 Pressed");
        return true;
      }
      else if (buttonNum == 3 && button3 == 0)
      {
        Serial.println("3 Pressed");
        return true;
      }
      else
      {
        return false;
      }
    }
  }
}
void winDisplay()
{
  digitalWrite(ledArray[0], HIGH);
  delay(75);
  digitalWrite(ledArray[0], LOW);
  delay(75);
  digitalWrite(ledArray[1], HIGH);
  delay(75);
  digitalWrite(ledArray[1], LOW);
  delay(75);
  digitalWrite(ledArray[2], HIGH);
  delay(75);
  digitalWrite(ledArray[2], LOW);
  delay(75);
  digitalWrite(ledArray[3], HIGH);
  delay(75);
  digitalWrite(ledArray[3], LOW);
  delay(75);
  digitalWrite(ledArray[2], HIGH);
  delay(75);
  digitalWrite(ledArray[2], LOW);
  delay(75);
  digitalWrite(ledArray[1], HIGH);
  delay(75);
  digitalWrite(ledArray[1], LOW);
  delay(75);
  digitalWrite(ledArray[0], HIGH);
  delay(75);
  digitalWrite(ledArray[0], LOW);
  delay(75);
}

void loseDisplay()
{
  digitalWrite(ledArray[0], HIGH);
  digitalWrite(ledArray[1], HIGH);
  digitalWrite(ledArray[2], HIGH);
  digitalWrite(ledArray[3], HIGH);
  delay(200);
  digitalWrite(ledArray[0], LOW);
  digitalWrite(ledArray[1], LOW);
  digitalWrite(ledArray[2], LOW);
  digitalWrite(ledArray[3], LOW);
  delay(200);
}
